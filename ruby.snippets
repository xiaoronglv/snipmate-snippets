##############################################################
############                  Flow                ############
##############################################################
snippet case
	case ${1:object}
	when ${2:condition}
		${3}
	end
	${4}
snippet when
	when ${1:condition}
		${2}
snippet if
	if ${1:condition}
		${2}
	end
	${3}
snippet ife
	if ${1:condition}
		${2}
	else
		${3}
	end
	${4}
snippet elsif
	elsif ${1:condition}
		${2}
snippet unless
	unless ${1:condition}
		${2}
	end
#
##############################################################
############                Definee               ############
##############################################################

snippet def
	def ${1:method_name}
		${2}
	end
	${3}
snippet cla class .. end
	class ${1:`substitute(Filename(), '^.', '\u&', '')`}
		${2}
	end
snippet cla class .. initialize .. end
	class ${1:`substitute(Filename(), '^.', '\u&', '')`}
		def initialize(${2:args})
			${3}
		end


	end
snippet cla class .. < ParentClass .. initialize .. end
	class ${1:`substitute(Filename(), '^.', '\u&', '')`} < ${2:ParentClass}
		def initialize(${3:args})
			${4}
		end


	end
snippet cla ClassName = Struct .. do .. end
	${1:`substitute(Filename(), '^.', '\u&', '')`} = Struct.new(:${2:attr_names}) do
		def ${3:method_name}
			${4}
		end


	end
snippet cla class BlankSlate .. initialize .. end
	class ${1:BlankSlate}
		instance_methods.each { |meth| undef_method(meth) unless meth =~ /\A__/ }
snippet cla class << self .. end
	class << ${1:self}
		${2}
	end
# class .. < DelegateClass .. initialize .. end
snippet cla-
	class ${1:`substitute(Filename(), '^.', '\u&', '')`} < DelegateClass(${2:ParentClass})
		def initialize(${3:args})
			super(${4:del_obj})

			${5}
		end


	end
snippet mod module .. end
	module ${1:`substitute(Filename(), '^.', '\u&', '')`}
		${2}
	end
snippet mod module .. module_function .. end
	module ${1:`substitute(Filename(), '^.', '\u&', '')`}
		module_function

		${2}
	end
snippet mod module .. ClassMethods .. end
	module ${1:`substitute(Filename(), '^.', '\u&', '')`}
		module ClassMethods
			${2}
		end

		module InstanceMethods

		end

		def self.included(receiver)
			receiver.extend         ClassMethods
			receiver.send :include, InstanceMethods
		end
	end
#
##############################################################
############         Attributes Accessor          ############
##############################################################

# attr_reader
snippet r
	attr_reader :${1:attr_names}
# attr_writer
snippet w
	attr_writer :${1:attr_names}
# attr_accessor
snippet rw
	attr_accessor :${1:attr_names}
# def self
snippet defs
	def self.${1:class_method_name}
		${2}
	end
#
##############################################################
############                Iterator              ############
##############################################################

snippet ea
	each { |${1:e}| ${2} }
snippet ead
	each do |${1:e}|
		${2}
	end
snippet inj
	inject(${1:init}) { |${2:mem}, ${3:var}| ${4} }
snippet injd
	inject(${1:init}) do |${2:mem}, ${3:var}|
		${4}
	end
snippet map
	map { |${1:e}| ${2} }
snippet mapd
	map do |${1:e}|
		${2}
	end
snippet all
	all? { |${1:e}| ${2} }
snippet any
	any? { |${1:e}| ${2} }
snippet sel
	select { |${1:e}| ${2} }
snippet seld
	select do |${1:e}|
		${2}
	end
snippet lam
	lambda { |${1:args}| ${2} }
snippet do
	do |${1:variable}|
		${2}
	end
snippet :
	:${1:key} => ${2:"value"}${3}

##############################################################
############                Minitest              ############
##############################################################

snippet tc
	require "test/minitest"

	class ${1:Test} < Test::Unit::TestCase
		${2}

	end
snippet ts
	setup do
		${1}
	end
	${2}
snippet test
	test "${1:description}" do
		${2}
	end
	${3}
snippet as
	assert ${1:test}, "${2:Failure message.}"
snippet asd
	assert_difference "${1:Model}.${2:count}", ${3:1} do
		${4}
	end
	${5}
snippet ase
	assert_equal ${1:expected}, ${2:actual}
snippet asne
	assert_not_equal ${1:unexpected}, ${2:actual}
snippet asnd
	assert_no_difference "${1:Model}.${2:count}", ${3:1} do
		${4}
	end
	${5}
snippet asn
	assert_nil ${1:instance}
snippet asnn
	assert_not_nil ${1:instance}
snippet asrr
	assert_response :redirect

snippet asrs
	assert_response :success

